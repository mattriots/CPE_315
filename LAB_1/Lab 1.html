<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  <meta http-equiv="Content-Language" content="en-us">
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
  <meta name="ProgId" content="FrontPage.Editor.Document">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Lab 1</title>
</head>
<body>
<p><b><font size="4">CPE 315<br>
Winter 2022<br>
Seng<br>
Lab #1<br>
Complete by 11:59pm 1/13/22 (Thursday night)<br>
<span style="color: rgb(255, 0, 0);">This assignment must be completed with a lab partner
</span><br> </font></b></p>
<p><b>Objectives</b>:</p>
<ul>
  <li>To practice MIPS programming</li>
  <li>Practice low-level bit manipulations</li>
</ul>
<p><b>Files</b>:</p>
<ol>
  <li><a href="https://users.csc.calpoly.edu/~jseng/Winter22/lab1/mipsdemo.asm">MIPS Sample Program</a> - Run this
yourself to see how the simulator
and assembly language work</li>
  <li><a href="http://spimsimulator.sourceforge.net/">SPIM Simulator</a> - If you like, you can download it for home use.  Otherwise, run spim on unix1 (from /home/jseng/bin/spim).</li>
</ol>
<p><b>Description</b>:</p>
<p>For this lab, you will use the SPIM simulator.&nbsp; This simulator
will simulate a MIPS processor by loading and running a file containing
MIPS assembly code.&nbsp; SPIM is available for free download and it is
available on unix1 by using '/home/jseng/bin/spim'.<br>
</p>
<p><b><font size="4"><span style="color: rgb(255, 0, 0);">Stepping
through sample code</span><br>
</font></b></p>
<span style="font-weight: bold;"></span>
<p>The sample code is not fully commented, but you should be able to
figure
out how input and output works.&nbsp; Please read through the following
tips: &nbsp;</p>
<ul>
  <li>The 'syscall' instruction calls
the operating system to perform a console input/output function.
&nbsp;Before 'syscall' is executed, a value parameter should be loaded
into $v0 to denote whether an input (5) or output (4=text, 1=number) operation is
desired.&nbsp; </li>
  <li>When running the code, the code is automatically placed at starting address:  0x00400000.</li>
  <li>To print a string, the start address of the string should
be loaded into $a0 (this can be seen in the example code).&nbsp; When
SPIM loads in strings, the first string starts at address
0x10010000.&nbsp; <span style="color: rgb(255, 0, 0);">In order to
find the start address for
the
next string, you will need to count over how many characters were in
the previous string.</span><br>
  </li>
  <li>'ori' means 'OR immediate'.&nbsp; The instruction does a bitwise
logical OR of a register with a constant.</li>
  <li>'lui' means 'load upper immediate'.&nbsp; The instruction loads a
16-bit number into the upper 16 bits of a register.</li>
  <li>use can 'step' to single step though the code an instruction at a
time</li>
  <li>Instructions for SPIM are here:&nbsp; <br>
  </li>
  <ul>
    <li><a href="http://pages.cs.wisc.edu/%7Elarus/spim.pdf">spim</a>
(command line on unix1:  /home/jseng/bin/spim)<br>
    </li>
  </ul>
  <li>Use only the instructions present on the MIPS instruction 
reference (listed on the left column under "Core Instruction Set") on 
Canvas.<br>
  </li>
   <li>Another reference for MIPS instruction formatting is located <a href="http://www.csc.calpoly.edu/~jseng/MD00565-2B-MIPS32-QRC-01.01.pdf">here</a>. (Be sure to still only use instructions listed on the MIPS instruction reference on Canvas)<br>
   </li>
</ul>
<p style="color: rgb(255, 0, 0);"><b><font size="4">Altering the code
for your
programs</font></b></p>
<p></p>
<p>For this assignment, you will write 4
programs.&nbsp; For each program write a corresponding function in
Java that does what is required, then convert your Java code to
MIPS assembly.&nbsp; The algorithms you use in Java should be the
same as the algorithms you use in assembly.&nbsp; <span style="color: rgb(255, 0, 0);">Place your Java code as comments in
the assembly file you turn in.</span>&nbsp; Make sure each
assembly program prompts the user
to accept
input and prints out a string stating what the answer is.<span style="font-weight: bold;"></span><br>
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
1.&nbsp; Write the following fast "mod" function.&nbsp; This function
uses no modulus operator, multiplication, or division - it uses
only basic arithmetic/logical operations (add, sub, and...).&nbsp;
The function takes two integers as inputs - a number (num), and a
divisor (div).&nbsp; You are guaranteed that div is a power of 2.&nbsp;
You want the remainder of num / div.&nbsp; For example, if&nbsp;num=22
(00010110 in binary) and div = 4 (100) would return 2 (10). Your algorithm
should *not* repeatedly subtract (or add) div from num.  Name your file <span style="font-weight: bold;">mod.asm</span>.&nbsp; <span style="color: rgb(255, 0, 0);">Program 1 only needs to work with
positive numbers.</span></p>
<p></p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
2.&nbsp; 

Write a program which prints the number that represents reverse-ordered 
binary of the input number.  Reverse the full 32-bit number (include 
leading 0's).  This means the your program will print the 32-bit number 
that is generated if the 32-bit input number's bits are written in 
reverse order (MSB becomes LSB and so on).&nbsp; Name your file <span style="font-weight: bold;">reverse.asm</span>.  <span style="color: rgb(255, 0, 0);">Program 2 only needs to work with
positive numbers as input.</span><br>
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
3. Write a function which divides a 64-bit unsigned number with a
31-bit unsigned
number.&nbsp; <span style="color: rgb(255, 0, 0);">The 31-bit divisor
is guaranteed to be a power of
2.</span>&nbsp; The program should take in the 64-bit as 2 32-bit
numbers:
first the upper 32 bits, then the lower 32 bits.&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; The answer
should be printed out as 2 32-bit numbers.&nbsp; Do not worry
if the output of your program is a negative number.&nbsp; PCSPIM prints
out numbers as signed numbers, so if one of the answers happens to
have a
leading 1, the number will appear as negative.&nbsp; Here are some test
cases (shown as dividend high 32, dividend low 32 / divisor = quotient 
high 32, quotient low 32): 1,1 / 65536 = 0,65536 and 2,10 / 65536 = 
0,131072 and 42,32 / 32 = 1,1342177281 and 210,64 / 64 = 3, 1207959553. 
Name your file <span style="font-weight: bold;">divide.asm</span>.  <span style="color: rgb(255, 0, 0);">Program 3 only needs to work with
positive numbers.</span>  Do not use repeated subtraction.<br>
</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
4.  Write a function which does exponentiation:  x raised to the power 
of y.  Your function should not use multiplies, but may use repeated 
addition.  Both x and y will be positive.  Name your file <span style="font-weight: bold;">exponent.asm</span>.<br>
</p>
<p></p>
<p><b><font size="4"><span style="color: rgb(255, 0, 0);">Turning in
the assignment</span><br>
</font></b></p>
<ul>
  <li>Include the following header at the top of your files:
<pre>  # Name:  include lab partner name as well
  # Section:  x
  # Description:  include a short description of your program
</pre>
  </li>

  <li>Use 'handin' to
turn in your 4 program files(the asm files).&nbsp; <br>
  </li>
  <li>Put your Java functions as
comments in the beginning of each corresponding assembly file.</li>
</ul>
<p><font size="4"><b>&nbsp;&nbsp; </b></font>At the unix 
prompt, type 'handin jseng' to see what assignments I am
accepting.&nbsp; For example, in order to handin a file named
'filename.asm', type: <br>
</p>
<pre>&nbsp;&nbsp;&nbsp; <big>handin jseng 315_lab1_x filename.asm</big> (where X is the section number)</pre>
<p>&nbsp;</p>


</body></html>